package com.example.auth_app_practice.Mapper;

import com.example.auth_app_practice.DTOs.UserDto;
import com.example.auth_app_practice.Model.User;
import org.mapstruct.*;

@Mapper(componentModel = "spring")
public interface UserMapper {

    // 1. ID: Generated by Database (UUID). User cannot pick their own ID.
    @Mapping(target = "id", ignore = true)

    // 2. Roles: Assigned by Business Logic (Default: USER). User cannot say "I am ADMIN".
//    @Mapping(target = "roles", ignore = true)

    // 3. Timestamps: Managed by JPA (@PrePersist). User cannot fake the date.
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)

    // ----------------Frontend -> Backend---------------------//
    User toEntity(UserDto userDto);

    // --- SCENARIO 1: Sending Data to Frontend (Login/Profile) ---
    @Mapping(target = "password", ignore = true)
    //-------------------BandEnd -> Frontend------------------------//
    UserDto toDto(User user);

    // --- 3. UPDATE: Patching an Existing User ---
    // This is the "Magic Method" for your Update Service.

    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    // 1. If DTO sends null (e.g., no name change), keep the old name. Don't set it to null.

    @Mapping(target = "id", ignore = true)        // SAFETY: Never change ID
//    @Mapping(target = "email", ignore = true)     // SAFETY: Email changes require verification (different flow)
//    @Mapping(target = "password", ignore = true)  // SAFETY: Password changes require hashing (different flow)
//    @Mapping(target = "roles", ignore = true)     // SAFETY: Only Admins can change roles
    @Mapping(target = "createdAt", ignore = true) // SAFETY: History cannot be rewritten

    void updateUserFromDto(UserDto dto, @MappingTarget User user);

}
